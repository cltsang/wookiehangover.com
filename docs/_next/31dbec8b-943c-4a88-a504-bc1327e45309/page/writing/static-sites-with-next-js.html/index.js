
          window.__NEXT_REGISTER_PAGE('/writing/static-sites-with-next-js.html', function() {
            var comp = module.exports=webpackJsonp([6],{502:function(e,t,s){e.exports=s(503)},503:function(e,t,s){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var n=s(11),p=r(n),o=s(3),a=r(o),i=s(24),l=r(i),d=s(25),c=r(d),h=s(28),y=r(h);t.default=function(e){var t={title:"How to Make a Static Blow with Next.js 3",slug:"static-sites-with-next-js",description:"I recently used Next.js 3 to make a static blog. Learn how I did it!",path:"pages/writing/static-sites-with-next-js.js",permalink:"writing/static-sites-with-next-js",updatedAt:"Tue Aug 15 08:46:59 2017 -0700"},s={type:"div",props:{},children:[{type:"h1",props:{},children:["How to Make a Static Blog with Next.js 3"]},"\n",{type:"p",props:{},children:[{type:"img",props:{src:"/static/img/next-blog-1.gif",alt:"make a static next.js blog"}}]},"\n",{type:"p",props:{},children:["üëã  Hey, so I recently finished converting this very website from a weird cobbled together mess of shell scripts and node into a fully-fledged modern JavaScript app with ",{type:"a",props:{href:"https://github.com/zeit/next.js"},children:["Next.js 3"]},"!"]},"\n",{type:"p",props:{},children:["I can write and edit posts entirely in Markdown and can even drop in custom HTML if I really need to (I mean how else am I gonna incorporate ",{type:"code",props:{},children:["<marquee>"]}," tags into my writing?), but now I have all sorts of fancy features like service worker prefetch, code splitting, and SPA style route changes. ",{type:"em",props:{},children:["Here's how I did it."]}]},"\n",{type:"p",props:{},children:[{type:"a",props:{href:"https://zeit.co/blog/next3"},children:["If you haven't heard of Next.js, it's a pretty cool, live reloading, totally-out-of-your-way tool for building webapps with React. You should use it."]}]},"\n",{type:"p",props:{},children:["As soon as the Zeit team announced plans to support serverless static exports, I was ready to go. I had already tried out Next.js for a few side projects, but really don't want to worry about running a server (even if it's free and painless) to keep my website running. I had even gone so far as to try scraping a compiled Next.js app with ",{type:"code",props:{},children:["wget"]}," to see if it was viable without a server, so Next's official support for static sites had me running out of excuses."]},"\n",{type:"p",props:{},children:["Here were my requirements for this humble website:"]},"\n",{type:"ul",props:{},children:["\n",{type:"li",props:{},children:["Fully static and deployable on Github pages."]},"\n",{type:"li",props:{},children:["Author posts in Markdown, with support for HTML things like ",{type:"code",props:{},children:["<details>"]}," tags."]},"\n",{type:"li",props:{},children:[{type:"em",props:{},children:["Fast."]}," Nobody's got time for slow websites."]},"\n",{type:"li",props:{},children:["Support my CSS preferences: ",{type:"a",props:{href:"http://tachyons.io/"},children:["Tachyons"]}," and some custom CSS compiled with ",{type:"a",props:{href:"http://postcss.org/"},children:["postcss"]}]},"\n"]},"\n",{type:"p",props:{},children:["Next.js seemed to have checked off all of those boxes, so I dug in and started prototyping."]},"\n",{type:"blockquote",props:{},children:["\n",{type:"p",props:{},children:['"Plan to throw one away; you will, anyhow".']},"\n"]},"\n",{type:"cite",props:{},children:["\n‚Äî ",{type:"i",props:{},children:["The Mythical Man-Month"]},", Fred Brooks (as popularized in ",{type:"i",props:{},children:["The Cathedral and the Bazaar"]}," by Eric Raymond)\n"]},"\n",{type:"p",props:{},children:["To start kicking the tires, ",{type:"a",props:{href:"https://github.com/wookiehangover/wookie-next"},children:["I built a prototype on the Next.js 3 beta a few months back"]},". I learned a few things but didn't end up with a website I wanted to deploy."]},"\n",{type:"p",props:{},children:["Ultimately I wasn't very happy with my first pass because I added a necessary-but-clunky build step to bridge the gap between my old posts and Next's routing model. Next.js creates routes that line up 1:1 with JavaScript files in the ",{type:"code",props:{},children:["pages/"]}," directory, so my first hacky attempt to get around that was to compile my markdown posts and write out files to the pages directory. I already had the scripts to generate static HTML from those files, so making them write ",{type:"code",props:{},children:[".js"]}," files that Next.js could consume was easy work."]},"\n",{type:"p",props:{},children:["With most of the site working, I ported over the css and other static assets, but I couldn't get over the kludginess of having to run a script every time I wanted to see something change. ",{type:"em",props:{},children:["Next's biggest selling point is having live reloading figured out already!"]}," So I shunted the would-be fork into another repo lacking the resolve to commit to the full re-write if the number of steps I needed in dev wasn't decreasing to one."]},"\n",{type:"details",props:{className:"pa4 ba b--rainbows"},children:["\n",{type:"summary",props:{},children:["\n  ",{type:"i",props:{},children:["A brief aside re: a nifty mardown rendering pipeline with Unified and Remark that should probably be in it's own post, but laziness."]},"\n"]},"\n",{type:"blockquote",props:{},children:["\n",{type:"p",props:{},children:["Every good work of software starts by scratching a developer's personal itch."]},"\n"]},"\n",{type:"cite",props:{},children:["\n‚Äî ",{type:"i",props:{},children:["The Cathedral and the Bazaar"]},", Eric Raymond\n"]},"\n",{type:"h3",props:{},children:["üê∞ Rabbit Hole: React from HTML Markdown"]},"\n",{type:"p",props:{},children:["One of the itches I ",{type:"em",props:{},children:["really"]}," wanted to scratch was the minor annoyance of having to use ",{type:"code",props:{},children:["__dangerouslySetInnerHtml"]}," to use most off-the-shelf markdown libraries with React. I even made it a bit harder on myself by lazily abusing markdown and sprikling bits of markup in many of my posts, since most React components that render markdown tend to fall back to to ",{type:"em",props:{},children:["dangerouslySet"]}," instead of parsing the markdown to generate a valid React component for the entire markdown document. This isn't a new or unsolved problem, so I did some research and ended up geeking out on text processing and abstract syntax trees. Turns out that there are already a bunch of well documented AST parser/compilers that support markdown on npm!"]},"\n",{type:"p",props:{},children:["I really didn't want to make clients do any of the parsing work. Even though parsing markdown can be optimized to be fast in modern browsers, making users download additional JavaScript and spend CPU time to convert posts clientside just didn't sit well with me."]},"\n",{type:"p",props:{},children:["I decided that in order to handle all of my posts with their mix of markdown and html, I would use ",{type:"a",props:{href:"https://unifiedjs.github.io/"},children:["Unified"]}," to make a rendering pipeline to go from markdown to HTML to a set of React components. There were already unified plugins for everything I wanted to do!"]},"\n",{type:"p",props:{},children:["There was even a ",{type:"a",props:{href:"https://github.com/mapbox/remark-react"},children:["ready-made solution for my exact gripe about ",{type:"code",props:{},children:["__dangerouslySetInnerHtml"]}]},"! Unfortunately, remark-react handles ",{type:"em",props:{},children:["most"]}," cases but didn't want to parse the raw HTMl generously sprinkled throughout my posts. Either way, I had found a small ecosystem of node modules that would make short work of lots of text processing problems. Neat!"]},"\n",{type:"p",props:{},children:["Here's what the code ended up looking like:"]},"\n",{type:"pre",props:{},children:[{type:"code",props:{className:"hljs language-js"},children:[{type:"span",props:{className:"hljs-keyword"},children:["const"]}," unified = ",{type:"span",props:{className:"hljs-built_in"},children:["require"]},"(",{type:"span",props:{className:"hljs-string"},children:["'unified'"]},")\n\nunified()\n  .use(",{type:"span",props:{className:"hljs-built_in"},children:["require"]},"(",{type:"span",props:{className:"hljs-string"},children:["'remark-parse'"]},"), {\n    ",{type:"span",props:{className:"hljs-attr"},children:["gfm"]},": ",{type:"span",props:{className:"hljs-literal"},children:["true"]},",\n    ",{type:"span",props:{className:"hljs-attr"},children:["footnotes"]},": ",{type:"span",props:{className:"hljs-literal"},children:["true"]},"\n  })\n  .use(",{type:"span",props:{className:"hljs-built_in"},children:["require"]},"(",{type:"span",props:{className:"hljs-string"},children:["'remark-rehype'"]},"), {\n    ",{type:"span",props:{className:"hljs-attr"},children:["allowDangerousHTML"]},": ",{type:"span",props:{className:"hljs-literal"},children:["true"]},"\n  })\n  .use(",{type:"span",props:{className:"hljs-built_in"},children:["require"]},"(",{type:"span",props:{className:"hljs-string"},children:["'rehype-raw'"]},"))\n  .use(",{type:"span",props:{className:"hljs-built_in"},children:["require"]},"(",{type:"span",props:{className:"hljs-string"},children:["'rehype-react'"]},"))"]}]},"\n",{type:"p",props:{},children:["To my suprise and delight, that process pipeline resulted in a totally usable React component! But it still would require some redundant processing on the client since the React component was being generated dynamicaly from a string of markdown. "]},"\n",{type:"p",props:{},children:["So how do you ",{type:"em",props:{},children:["cache"]}," a React component? Like, a whole component, not just the serialization of it's virtual dom. React provides tools to server render components in multiple ways, but you can't easily generate ",{type:"em",props:{},children:["jsx"]}," from a dynamically generated components. But there ",{type:"em",props:{},children:["is"]}," a techinique for dealing with a React as a compile output of an AST, evidenced by ",{type:"a",props:{href:"https://github.com/rhysd/rehype-react"},children:["react-rehype"]}," at the end of that Unified markdown pipeline."]},"\n",{type:"p",props:{},children:["React has a dead simple API for creating components without JSX in ",{type:"code",props:{},children:["React.createElement()"]},". Since it's just plain JavaScript and doesn't require any functions or non-serializable data structures, it turns out that you can make a JSON structure that represents a set of React components pretty easily. I had run into a use case for this same trick at work, so I put it to use again here: I modified the last step of my Unified pipeline to return JSON instead of a React component. ",{type:"a",props:{href:""},children:[{type:"code",props:{},children:["rehype-react"]}]}," made this a cinch, since they allow you to pass a custom method for ",{type:"code",props:{},children:["createElement"]},"."]},"\n",{type:"pre",props:{},children:[{type:"code",props:{className:"hljs language-js"},children:["remarkPipeline().use(rehypeReact, {\n  ",{type:"span",props:{className:"hljs-attr"},children:["createElement"]},": ",{type:"span",props:{className:"hljs-function"},children:["(",{type:"span",props:{className:"hljs-params"},children:["type, props, children"]},") =>"]}," ({ type, props, children })\n})"]}]},"\n",{type:"p",props:{},children:["From there, I made a ",{type:"a",props:{href:""},children:["simple component"]}," to transform the result from ",{type:"a",props:{href:""},children:[{type:"code",props:{},children:["rehype-react"]}]}," back into a React component:"]},"\n",{type:"pre",props:{},children:[{type:"code",props:{className:"hljs language-jsx"},children:["<ComponentTree components={components} />"]}]},"\n"]},"\n",{type:"h2",props:{},children:["Markdown ‚û°Ô∏è Webpack ‚û°Ô∏è Next.js"]},"\n",{type:"p",props:{},children:["What I really wanted was to write in Markdown posts and have Next.js pick up the changes automatically."]},"\n",{type:"p",props:{},children:["By default, next will use any JavaScript modules that export a React compontent in your ",{type:"code",props:{},children:["pages/"]}," directory. Writing markdown inline in a file with code in it is possible, but gross; same for duplicating the same boilerplate file for each post and importing the markdown source from some other directory. I wanted to skip all that an go straight from Markdown directly into Next's build and compile pipeline."]},"\n",{type:"p",props:{},children:["üí° The lightbulb moment came when I realized the power of Next's support for custom Webpack configuration."]},"\n",{type:"p",props:{},children:["With a custom Webpack config, I could write my own ",{type:"a",props:{href:"https://webpack.js.org/concepts/loaders/"},children:["Webpack Loader"]}," to compile my markdown source files into modules on the spot! And better yet, I already had a build script from my prototype that was doing most of what I needed to do in the webpack plugin. I needed to change was how my build script found out about files (reading them from disk vs. passed in by webpack) and how it output the results (again, writing to disk vs. passing the result back to webpack). The loader plugin interface was dead simple:"]},"\n",{type:"pre",props:{},children:[{type:"code",props:{className:"hljs language-js"},children:[{type:"span",props:{className:"hljs-built_in"},children:["module"]},".exports = ",{type:"span",props:{className:"hljs-function"},children:[{type:"span",props:{className:"hljs-keyword"},children:["function"]},"(",{type:"span",props:{className:"hljs-params"},children:["source"]},") "]},"{\n  ",{type:"span",props:{className:"hljs-keyword"},children:["const"]}," done = ",{type:"span",props:{className:"hljs-keyword"},children:["this"]},".async()\n\n  renderPost(source, ",{type:"span",props:{className:"hljs-keyword"},children:["this"]},".resourcePath)\n    .catch(done).then(",{type:"span",props:{className:"hljs-function"},children:[{type:"span",props:{className:"hljs-params"},children:["post"]}," =>"]}," done(",{type:"span",props:{className:"hljs-literal"},children:["null"]},", post))\n}"]}]},"\n",{type:"p",props:{},children:["Where ",{type:"code",props:{},children:["renderPost(source, resourcePath)"]}," was the middle bit of my prototyped static rendering pipeline, refactored to only need a string of the file content and the path of the file being rendered. This is one of the easiest changes to make, since it took a method formerly reliant on ",{type:"em",props:{},children:["side effects"]},", namely reading and writing to disk, and made it a pure function. Any time you can make a method that's passed an input and return a result, you should. Decomposing your assumptions about side effects will almost always save time. My favorite (longish) primer on this concept is still Gary Bernhardt's talk ",{type:"em",props:{},children:[{type:"a",props:{href:"https://www.destroyallsoftware.com/talks/boundaries"},children:["Boundaries"]}]},"."]},"\n",{type:"p",props:{},children:["The last step was to add it to the webpack extension point in ",{type:"code",props:{},children:["next.config.js"]},":"]},"\n",{type:"pre",props:{},children:[{type:"code",props:{className:"hljs language-js"},children:[{type:"span",props:{className:"hljs-built_in"},children:["module"]},".exports = {\n  webpack(config) {\n    config.module.rules.push({\n      ",{type:"span",props:{className:"hljs-attr"},children:["test"]},": ",{type:"span",props:{className:"hljs-regexp"},children:["/\\.html\\.js$/"]},",\n      ",{type:"span",props:{className:"hljs-attr"},children:["include"]},": ",{type:"span",props:{className:"hljs-string"},children:["'./pages/writing'"]},",\n      ",{type:"span",props:{className:"hljs-attr"},children:["loader"]},": ",{type:"span",props:{className:"hljs-string"},children:["'./src/post-loader'"]},"\n    })\n    ",{type:"span",props:{className:"hljs-keyword"},children:["return"]}," config\n  }\n}"]}]},"\n",{type:"h2",props:{},children:["Building and Deploying"]},"\n",{type:"p",props:{},children:["Unlike in my early prototype, Next.js 3 supports creating a complete static site from any next app with ",{type:"code",props:{},children:["next export"]},". To tell it what routes and pages to export, you need to add some configuration to ",{type:"code",props:{},children:["next.config.js"]},". Here's what mine looks like:"]},"\n",{type:"pre",props:{},children:[{type:"code",props:{className:"hljs language-js"},children:[{type:"span",props:{className:"hljs-built_in"},children:["module"]},".exports = {\n  exportPathMap() {\n    ",{type:"span",props:{className:"hljs-keyword"},children:["return"]}," {\n      ",{type:"span",props:{className:"hljs-string"},children:['"/"']},": { ",{type:"span",props:{className:"hljs-attr"},children:["page"]},": ",{type:"span",props:{className:"hljs-string"},children:['"/"']}," },\n      ",{type:"span",props:{className:"hljs-string"},children:['"/cv.html"']},": { ",{type:"span",props:{className:"hljs-attr"},children:["page"]},": ",{type:"span",props:{className:"hljs-string"},children:['"/cv.html"']}," },\n      ",{type:"span",props:{className:"hljs-string"},children:['"/writing/2016-reading-list.html"']},": { ",{type:"span",props:{className:"hljs-attr"},children:["page"]},": ",{type:"span",props:{className:"hljs-string"},children:['"/writing/2016-reading-list.html"']}," },\n      ",{type:"span",props:{className:"hljs-string"},children:['"/writing/2017-reading-list.html"']},": { ",{type:"span",props:{className:"hljs-attr"},children:["page"]},": ",{type:"span",props:{className:"hljs-string"},children:['"/writing/2017-reading-list.html"']}," },\n      ",{type:"span",props:{className:"hljs-comment"},children:["// ..."]},"\n    }\n  }\n}"]}]},"\n",{type:"p",props:{},children:["Then I changed my build step to run ",{type:"code",props:{},children:["next build && next export --docs"]}," and I with surprisingly little drama was ready to deploy to Github pages!"]},"\n",{type:"p",props:{},children:["Normally I'd be worried that I'd have missed some minor detail in a major change like swapping out the entire backend of a website, but in essense what I was doing here wasn't all that big of a change: my static HTML, JavaScript, and CSS in the ",{type:"code",props:{},children:["docs/"]}," directory was still there, but was being built by a different tool chain. I pushed the first commit with the switch to Next.js and waited patiently while the build ran on Travis CI."]},"\n",{type:"p",props:{},children:["...And that was it. I had more or less completely moved my static site into a totally modern React app with Next.js. The whole thing is ",{type:"a",props:{href:""},children:["open source"]},", so feel free to kick the tires and ask questions if you have any üòä"]},"\n",{type:"p",props:{},children:["Here are the relevant pieces of code:"]},"\n",{type:"ul",props:{},children:["\n",{type:"li",props:{},children:[{type:"strong",props:{},children:["post-loader.js"]}," ‚Äì ",{type:"a",props:{href:"https://github.com/wookiehangover/wookiehangover.com/blob/master/src/post-loader.js"},children:["webpack loader"]}]},"\n",{type:"li",props:{},children:[{type:"strong",props:{},children:["static-sites-with-next-js.html.js"]}," ‚Äì ",{type:"a",props:{href:"https://github.com/wookiehangover/wookiehangover.com/blob/master/pages/writing/static-sites-with-next-js.html.js"},children:["a markdown post with embedded HTML"]}]},"\n",{type:"li",props:{},children:[{type:"strong",props:{},children:["react-to-hast.js"]}," ‚Äì ",{type:"a",props:{href:"https://github.com/wookiehangover/wookiehangover.com/blob/master/src/react-to-hast.js"},children:["markdown compiler with Unified.js"]}]},"\n",{type:"li",props:{},children:[{type:"strong",props:{},children:["component-tree.js"]}," ‚Äì ",{type:"a",props:{href:"https://github.com/wookiehangover/wookiehangover.com/blob/master/src/components/component-tree.js"},children:["React component for rendering JSON AST"]}]},"\n"]},"\n",{type:"h3",props:{},children:["Gotcha's!"]},"\n",{type:"p",props:{},children:["A few snags I ran into:"]},"\n",{type:"ul",props:{},children:["\n",{type:"li",props:{},children:["\n",{type:"p",props:{},children:["Github pages still perversely retains some of it's Jekyll roots, and ignores file and directory names that start with and underscore üôÑ"]},"\n",{type:"ul",props:{},children:["\n",{type:"li",props:{},children:[{type:"strong",props:{},children:["Fix:"]}," add ",{type:"code",props:{},children:[".nojekyll"]}," to your ",{type:"code",props:{},children:["docs/"]},' directory (or whatever is configured in the "Pages" portion of your repo config in Github)']},"\n"]},"\n"]},"\n",{type:"li",props:{},children:["\n",{type:"p",props:{},children:["The ",{type:"code",props:{},children:[".html.js"]}," file extension on the posts was because I wanted backwards compatabilty with my static html version, which used plain old html files"]},"\n",{type:"ul",props:{},children:["\n",{type:"li",props:{},children:[{type:"em",props:{},children:["Minor annoyance:"]}," ",{type:"code",props:{},children:["next export"]}," adds directories for every static file to avoid the .html extension showing up in the path, but now I have urls with trailing slashes"]},"\n"]},"\n"]},"\n"]},"\n",{type:"p",props:{},children:[{type:"marquee",props:{},children:["And here's that ",{type:"code",props:{},children:["<marquee>"]}," tag to prove I wasn't joking about supporting arbitraty HTML in posts"]}]}]};return a.default.createElement(l.default,t,a.default.createElement(c.default,(0,p.default)({},s,{components:y.default})))}}},[502]);
            return { page: comp.default }
          })
        